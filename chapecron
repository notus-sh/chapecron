#!/bin/env bash

# Environment variables
: ${CHAPECRON_DEBUG:=0}
: ${CHAPECRON_PATH_PREFIX:=}

: ${CHAPECRON_BASH_VERSION:=${BASH_VERSINFO[0]}}


# Unofficial Bash strict mode
set -euo pipefail
[ $CHAPECRON_DEBUG = 1 ] && set -x
IFS=$'\n\t'


##
## Global variables
##

## Exit statuses
# See https://goo.gl/6uEMX3 for full reference
declare -r EX_USAGE=64					# Command used incorrectly
declare -r EX_UNAVAILABLE=69		# Unavailable dependency
declare -r EX_OSFILE=72					# Configuration file missing or wrong
declare -r EX_NOPERM=77					# Insufficient permissions
declare -r EX_CONFIG=78					# Missing or wrong configuration

## Command line arguments
declare COMMAND=''
# Default options
declare CONFIG_FILE=''
# Default flags
declare -i VERBOSE=0
declare -i HELP=0


#
# Utilities
#
utils::log() {
	[ $VERBOSE -ge $1 ] || return 0

	local redirect=""
	[ $# -eq 3 ] && ([ "$3" == "stderr" ] || [ "$3" == "STDERR" ]) && redirect=" >&2"

	eval "echo \"$2\"$redirect"
}

utils::error() {
	utils::log 0 "$@" "stderr"
}

utils::info() {
	utils::log 1 "$@"
}

utils::debug() {
	utils::log 2 "$@"
}

utils::fail() {
	local exit_code=$1
	shift

	[ $# -gt 0 ] && utils::error "$@"
	exit $exit_code
}

#
# Array functions
#
array::search() {
	local needle=$1 value
	shift
	
	eval set -- $@
	for value in $@; do
		[ "$value" == "$needle" ] && return 0
	done
	return 1
}

array::merge() {
	local merged=() value
	
	eval set -- $@
	for value in $@; do
		if ( ! array::search $value ${merged[@]} ); then
			merged+=("$value")
		fi
	done
	
  echo "${merged[@]}"
}


#
# Dependency management
#
dependencies::getopt() {
	local exit_code

	set +e
	getopt --test > /dev/null
	exit_code=$?
	set -e

	[ $exit_code -ne 4 ] && return 1
	return 0
}

dependencies::bash4() {
	[ $CHAPECRON_BASH_VERSION -lt 4 ] && return 1
	return 0
}

dependencies::all() {
	dependencies::getopt || \
		utils::fail $EX_UNAVAILABLE \
								"Missing dependency: enhanced getopt"
		            
	dependencies::bash4  || \
		utils::fail $EX_UNAVAILABLE \
								"Missing dependency: bash 4.0+"
}


#
# Command line options
#
options::usage() {
	cat <<-USAGE
		chapecron: look after your crons while you are away
		Usage: $0 [-v,--verbose] [-h,--help] -- COMMAND
		Options:
		  -c,--config   Specify a configuration file (See below)
		  -h,--help     Print this help and exit
		  -v,--verbose  More verbose output.
		                You can specify this option more than once
		
		By default, chapecron will look for configuration files at:
		
		- /etc/chapecron/chapecron.conf
		- XDG_CONFIG_HOME/chapecron/chapecron.conf
		  (usually ~/.config/chapecron/chapecron.conf)
		
		When specifying a configuration file as a command line option,
		only this file will be considered.
	USAGE
}

options::get() {
	local parsed
	
	parsed=$(getopt --options=hvc: \
									--longoptions=help,verbose,config: \
									--name "$0" \
									-- "$@")
	eval set -- "$parsed"

	while :; do
		case "$1" in
			-c|--config)
				CONFIG_FILE=$2
				shift 2
				;;
			-v|--verbose)
				VERBOSE+=1
				shift
				;;
			-h|--help)
				HELP=1
				shift
				;;
			--)
				shift
				break
				;;
			*)
				utils::fail $EX_USAGE \
										"Unsupported option $1. Use $0 -h to get help"
				;;
		esac
	done

	COMMAND=$(echo "$*"	| tr "\\n" " ")

	[ $HELP -eq 1 ] && options::usage && exit 0
	
	[ -z "$COMMAND" ] && \
		utils::fail $EX_USAGE \
								"No command to look after. Use $0 -h to get help"
	
	eval "$(printf 'chapecron::command() { %s; return $?; }' $COMMAND)"
}


#
# Configuration
#
declare -A CONFIG

declare -a CONFIG_MERGEABLE

CONFIG_MERGEABLE+=('plugins')

config::dir() {
	local path
	
	case "$1" in
		sys)
			path="/etc"
			;;
		user)
			# `$(eval echo "~$(whoami)")` seems to be an overly complicated way
			# to get $HOME but Sharness mess with $HOME
			path=$(   ([ -z ${XDG_CONFIG_HOME+x} ] || [ -z "$XDG_CONFIG_HOME" ]) \
							&& echo "$(eval echo "~$(whoami)")/.config" \
							|| echo "$XDG_CONFIG_HOME" \
						)
			;;
	esac
	
	echo "${path%/}/chapecron/"
	return 0
}

declare -r CONFIG_DIR_SYS=$(config::dir 'sys')
declare -r CONFIG_DIR_USR=$(config::dir 'user')

config::defaults() {
	CONFIG=( ["plugins"]="" )
}

config::loadfile() {
	local to_load=$1 tmp_conf name value

	[ -e "$to_load" ] || \
		utils::fail $EX_OSFILE \
								"Configuration file $to_load does not exist"

	[ -r "$to_load" ] || \
		utils::fail $EX_OSFILE \
								"Configuration file $to_load can not be read"

	utils::info "Loading configuration from file $to_load"


	tmp_conf=$(mktemp 'chapecron-config.XXXXXXXXXX')
	utils::debug "Temporary configuration file created as $tmp_conf"
	if [ $CHAPECRON_DEBUG -eq 0 ]; then
		trap "{ rm \"$tmp_conf\"; }" EXIT
		utils::debug "Temporary configuration file set to be deleted after execution"
	fi

	grep -vE '^$' "$to_load" | grep -vE '^#' > "$tmp_conf"
	while IFS="=" read -r name value || [ -n "$name" ]; do
		if (array::search "$name" "${CONFIG_MERGEABLE[@]}"); then
			CONFIG["$name"]="$(array::merge "${CONFIG["$name"]}" "$value")"
		else
			CONFIG["$name"]="$value"
		fi
	done < "$tmp_conf"
}

config::load() {

	config::defaults
		
	if [ -n "$CONFIG_FILE" ]; then
		config::loadfile "$CONFIG_FILE"
		return
	fi

	local f
	local -a config_files
	
	config_files=(
		"${CHAPECRON_PATH_PREFIX%/}${CONFIG_DIR_SYS%/}/chapecron.conf"
		"${CHAPECRON_PATH_PREFIX%/}${CONFIG_DIR_USR%/}/chapecron.conf"
	)

	for f in "${config_files[@]}"; do
		utils::debug "Looking for a configuration file at $f"
		if [ -e "$f" ]; then
			config::loadfile "$f"
		fi
	done
}


#
# Plugins
#
declare -a PLUGINS_AVAILABLE
declare -r PLUGINS_DIR="$(dirname $(realpath $0))/plugins.d"


plugins::load() {
	local plugin f functions
	
	functions=$(declare -F | cut -d ' ' -f3)
	
	for plugin in "$PLUGINS_DIR"/*.sh; do
		[ -r "$plugin" ] || \
			utils::fail $EX_NOPERM \
									"Plugin $plugin can not be read"
	
		utils::debug "Loading plugin from $plugin"
	  source "$plugin"
	done
	
	for f in $(declare -F | cut -d ' ' -f3); do
	  if ( ! array::search "$f" $functions); then
	    PLUGINS_AVAILABLE+=("$f")
	  fi
	done
}


#
# Stack management
#
declare -a STACK
declare -i STACK_COUNTER=0

stack::add() {
	STACK+=("$@")
}

stack::next() {
	local next=${STACK[$STACK_COUNTER]}
	STACK_COUNTER+=1
	$next
}

stack::run() {
	STACK_COUNTER=0
	stack::next
	return $?
}

stack::build() {
	local plugins plugin
	
	stack::add "chapecron::mktmp"
	stack::add "chapecron::capture"
	
	if [ -n "${CONFIG['plugins']}" ]; then
		for plugin in $(echo "${CONFIG['plugins']}" | tr " " "\\n"); do
			if ( ! array::search "$plugin" "${PLUGINS_AVAILABLE[@]}"); then
				utils::fail $EX_CONFIG "Unknown plugin: $plugin"
			fi
			
			stack::add "$plugin"
		done
	fi
	
	stack::add "chapecron::command"
}


#
# Output
#
report::options() {
	utils::info  "Command to be monitored: $COMMAND"
	utils::debug "-- Command line options detected --"
	utils::debug "config file = ${CONFIG_FILE:-undefined}"
	utils::debug "verbose = $VERBOSE"
	utils::debug "-- Command line options ends --"
}

report::config() {
	local key
	
	utils::debug "-- Configuration loaded --"
	for key in "${!CONFIG[@]}"; do
		utils::debug "$key = ${CONFIG[$key]}"
	done
	utils::debug "-- Configuration ends --"
}

report::plugins() {
	local plugin
	
	utils::debug "-- Plugins available --"
	for plugin in "${PLUGINS_AVAILABLE[@]}"; do
		utils::debug "$plugin"
	done
	utils::debug "-- Plugins ends --"
}

report::stack() {
	local middleware
	
	utils::debug "-- Stack build --"
	for middleware in "${STACK[@]}"; do
		utils::debug "$middleware"
	done
	utils::debug "-- Stack ends --"
}

report::trace() {
	echo "Cronic detected failure or error output for the command:"
	echo "$@"
	echo
	echo "RESULT CODE: $RESULT"
	echo
	echo "ERROR OUTPUT:"
	cat "$ERR"
	echo
	echo "STANDARD OUTPUT:"
	cat "$OUT"
	if [ "$TRACE" != "$ERR" ]; then
		echo
		echo "TRACE-ERROR OUTPUT:"
		cat "$TRACE"
	fi
}

#
# Chapecron own middlewares
#
chapecron::mktmp() {
	declare -g TMP
	declare -g OUT
	declare -g ERR
	declare -g TRACE

	TMP=$(mktemp -d 'chapecron.XXXXXXXXXX')
	OUT=$TMP/cronic.out
	ERR=$TMP/cronic.err
	TRACE=$TMP/cronic.trace

	utils::debug "Output files created in $TMP"
	if [ $CHAPECRON_DEBUG -eq 0 ]; then
		trap "{ rm -rf \"$TMP\"; }" EXIT
		utils::debug "Output files set to be deleted after execution"
	fi

	stack::next
	return $?
}

chapecron::capture() {
	set +e
	stack::next >"$OUT" 2>"$TRACE"
	RESULT=$?
	set -e

	PATTERN="^${PS4:0:1}\\+${PS4:1}"
	if grep -aq "$PATTERN" "$TRACE"; then
		! grep -av "$PATTERN" "$TRACE" > "$ERR"
	else
		ERR=$TRACE
	fi

	if ([ $RESULT -ne 0 ] || [ -s "$ERR" ]); then
		echo -e "$(report::trace "$COMMAND")"
	fi

	return $RESULT
}


#
# Here we go!
#
dependencies::all

options::get $@ 	&& report::options
config::load			&& report::config
plugins::load			&& report::plugins
stack::build			&& report::stack

stack::run
exit $?

