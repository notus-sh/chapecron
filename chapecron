#!/bin/bash

# Environment variables
: ${CHAPECRON_DEBUG:=0}
: ${CHAPECRON_PATH_PREFIX:=}


# Unofficial Bash strict mode
set -euo pipefail
[ $CHAPECRON_DEBUG = 1 ] && set -x
IFS=$'\n\t'


#
# Exit statuses
# (Exit code should be narrowed to the range 64-113 to match
# C/C++ standards and not clash with reserved ones)
#
ERROR_MISSING_DEPENDENCY=65
ERROR_INVALID_ARGUMENTS=66
ERROR_UNLOADABLE_CONFIG=70


#
# Command line arguments
#

# Default flags
declare -i VERBOSE=0
declare -i HELP=0

# Default options
declare CONFIG_FILE=''


#
# Utilities
#
utils::log() {
  [ $VERBOSE -ge $1 ] || return 0
  
  local redirect=""
  [ $# -eq 3 ] && ([ "$3" == "stderr" ] || [ "$3" == "STDERR" ]) && redirect=" >&2"
  
	eval "echo \"$2\"$redirect"
}

utils::error() {
	utils::log 0 "$@" "stderr"
}

utils::info() {
	utils::log 1 "$@"
}

utils::debug() {
	utils::log 2 "$@"
}

utils::fail() {
  local exit_code=$1
  shift
  
	[ $# -gt 0 ] && utils::error "$@"
	exit $exit_code
}

#
# Array functions
#
array::search() {
  local needle=$1
  local value
  
  shift
  for value in $(echo $@ | tr " " "\\n"); do
    [ "$value" == "$needle" ] && return 0
  done
  return 1
}

array::merge() {
  local merged=()
  local v
  
  for v in $(echo $@ | tr " " "\\n"); do
    if ( ! array::search $v ${merged[@]} )
    then
      merged+=("$v")
    fi
  done
  echo "${merged[@]}"
}


#
# Dependency management
#
dependencies::getopt() {
  local exit_code
  
  set +e
  getopt --test > /dev/null
  exit_code=$?
  set -e
  
  [ $exit_code -ne 4 ] && return 1
  return 0
}

dependencies::bash4() {
  [ ${BASH_VERSINFO[0]} -lt 4 ] && return 1
  return 0
}


#
# Configuration
#
declare -A CONFIG
declare -a CONFIG_MERGEABLE

CONFIG_MERGEABLE+=('plugins')

# `$(eval echo "~$(whoami)")` seems to be an overly complicated way
# to get $HOME but Sharness mess with $HOME
CONFIG_HOME_USR=$(   ([ -z ${XDG_CONFIG_HOME+x} ] || [ -z "$XDG_CONFIG_HOME" ]) \
                  && echo "$(eval echo "~$(whoami)")/.config" \
                  || echo "$XDG_CONFIG_HOME" \
                )

CONFIG_DIR_SYS=/etc/chapecron/
CONFIG_DIR_USR=${CONFIG_HOME_USR%/}/chapecron/

config::defaults() {
  CONFIG=( ["plugins"]="" )
}

config::loadfile() {
  local _file=$1
  local _tmp
  
  [ -e "$_file" ] || \
    utils::fail $ERROR_UNLOADABLE_CONFIG \
                "Configuration file $_file does not exist"
  
  [ -r "$_file" ] || \
    utils::fail $ERROR_UNLOADABLE_CONFIG \
                "Configuration file $_file can not be read"
  
  utils::info "Loading configuration from file $_file"
  
  
  _tmp=$(mktemp 'chapecron-config.XXXXXXXXXX')
  utils::debug "Temporary configuration file created as $_tmp"
	if [ $CHAPECRON_DEBUG -eq 0 ]
	then
	  trap "{ rm \"$_tmp\"; }" EXIT
	  utils::debug "Temporary configuration file set to be deleted after execution"
	fi
  
  grep -vE '^$' "$_file" | grep -vE '^#' > "$_tmp"
  while IFS="=" read -r name value || [ -n "$name" ]; do
    if (array::search "$name" "${CONFIG_MERGEABLE[@]}")
    then
      CONFIG["$name"]=$(array::merge "${CONFIG["$name"]}" "$value")
    else
      CONFIG["$name"]="$value"
    fi
  done < "$_tmp"
}

config::load() {
  if [ -n "$CONFIG_FILE" ]
  then
    config::loadfile "$CONFIG_FILE"
    return
  fi
  
  local _config_files=(
    "${CHAPECRON_PATH_PREFIX%/}${CONFIG_DIR_SYS%/}/chapecron.conf"
    "${CHAPECRON_PATH_PREFIX%/}${CONFIG_DIR_USR%/}/chapecron.conf"
  )
  
  for f in "${_config_files[@]}"; do
    utils::debug "Looking for a configuration file at $f"
    if [ -e "$f" ]
    then
      utils::info "Configuration file found: $f"
      config::loadfile "$f"
    fi
  done
}


#
# Stack management
#
declare -a STACK
declare -i STACK_COUNTER=0

stack::add() {
	STACK+=("$@")
}

stack::next() {
	local NEXT_COMMAND=${STACK[$STACK_COUNTER]}
	STACK_COUNTER+=1
	$NEXT_COMMAND
}

stack::run() {
	STACK_COUNTER=0
	stack::next
	return $?
}


#
# Output
#
output::trace() {
	echo "Cronic detected failure or error output for the command:"
	echo "$@"
	echo
	echo "RESULT CODE: $RESULT"
	echo
	echo "ERROR OUTPUT:"
	cat "$ERR"
	echo
	echo "STANDARD OUTPUT:"
	cat "$OUT"
	if [ "$TRACE" != "$ERR" ]
	then
		echo
		echo "TRACE-ERROR OUTPUT:"
		cat "$TRACE"
	fi
}

#
# Chapecron own middlewares
#
chapecron::mktmp() {
	local TMP
	local OUT
	local ERR
	local TRACE
	
	TMP=$(mktemp -d 'chapecron.XXXXXXXXXX')
	OUT=$TMP/cronic.out
	ERR=$TMP/cronic.err
	TRACE=$TMP/cronic.trace
	
	export OUT ERR TRACE
	
	utils::debug "Output files created in $TMP"
	if [ $CHAPECRON_DEBUG -eq 0 ]
	then
	  trap "{ rm -rf \"$TMP\"; }" EXIT
	  utils::debug "Output files set to be deleted after execution"
	fi
	
	stack::next
	return $?
}

chapecron::run() {
	set +e
	stack::next >"$OUT" 2>"$TRACE"
	RESULT=$?
	set -e
	
	PATTERN="^${PS4:0:1}\\+${PS4:1}"
	if grep -aq "$PATTERN" "$TRACE"
	then
		! grep -av "$PATTERN" "$TRACE" > "$ERR"
	else
		ERR=$TRACE
	fi
	
	if ([ $RESULT -ne 0 ] || [ -s "$ERR" ])
	then
		echo -e "$(output::trace "$COMMAND")"
	fi
	
	return $RESULT
}


#
# Here we go!
#
dependencies::getopt || \
  utils::fail $ERROR_MISSING_DEPENDENCY \
              "Missing dependency: enhanced getopt"
              
dependencies::bash4  || \
  utils::fail $ERROR_MISSING_DEPENDENCY \
              "Missing dependency: bash 4.0+"

# Options
SHORT_OPTIONS=hvc:
LONG_OPTIONS=help,verbose,config:

self::usage() {
	cat <<-USAGE
		chapecron: look after your crons while you are away
		Usage: $0 [-v,--verbose] [-h,--help] -- COMMAND
		Options:
		  -c,--config   Specify a configuration file (See below)
		  -h,--help     Print this help and exit
		  -v,--verbose  More verbose output.
		                You can specify this option more than once
		
		By default, chapecron will look for configuration files at:
		
		- /etc/chapecron/chapecron.conf
		- XDG_CONFIG_HOME/chapecron/chapecron.conf
		  (usually ~/.config/chapecron/chapecron.conf)
		
		When specifying a configuration file as a command line option,
		only this file will be considered.
	USAGE
}

PARSED=$(getopt --options=$SHORT_OPTIONS --longoptions=$LONG_OPTIONS --name "$0" -- "$@")
eval set -- "$PARSED"
while :; do
	case "$1" in
		-c|--config)
			CONFIG_FILE=$2
			shift 2
			;;
		-v|--verbose)
			VERBOSE+=1
			shift
			;;
		-h|--help)
			HELP=1
			shift
			;;
		--)
			shift
			break
			;;
		*)
		  utils::fail $ERROR_INVALID_ARGUMENTS \
		              "Unsupported option $1. Use $0 -h to get help"
			;;
	esac
done

COMMAND="$*"


[ $HELP -eq 1 ] && self::usage && exit 0


[ -z "$COMMAND" ] && \
  utils::fail $ERROR_INVALID_ARGUMENTS \
              "No command to look after. Use $0 -h to get help"


utils::info  "Command to be monitored: $COMMAND"

utils::debug "Command line options detected:"
utils::debug "config file: ${CONFIG_FILE:-undefined}"
utils::debug "verbose: $VERBOSE"

config::defaults
config::load

utils::debug "-- Configuration loaded --"
for key in "${!CONFIG[@]}"; do
  utils::debug "$key = ${CONFIG[$key]}"
done
utils::debug "-- Configuration ends --"


eval_command() {
  eval "$COMMAND"
	return $?
}

# Build the middleware stack and run it
stack::add chapecron::mktmp
stack::add chapecron::run
stack::add eval_command

stack::run

exit $?

