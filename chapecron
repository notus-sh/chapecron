#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

#
# Exit statuses
# (Exit code should be narrowed to the range 64-113 to match
# C/C++ standards and not clash with reserved ones)
#
ERROR_MISSING_DEPENDENCY=65
ERROR_UNSUPPORTED_OPTION=70

#
# Command line arguments
#

# Default flags
declare -i VERBOSE=0
declare -i HELP=0

# Default options
declare CONFIG_FILE


CONFIG_DIR_SYS=/etc/chapecron/
CONFIG_DIR_USR=$(([ -z ${XDG_CONFIG_HOME+x} ] || [ -z "$XDG_CONFIG_HOME" ]) \
                  && echo "~/config" \
                  || echo $XDG_CONFIG_HOME \
                )"chapecron/"



#
# Utilities
#
utils::log() {
  [ $VERBOSE -le $1 ] || return
  
  local redirect=""
  ([ "$3" = "stderr" ] || [ "$3" = "STDERR" ]) && redirect=" >&2"
  
	eval "echo \"$2\"$redirect"
}

utils::error() {
	utils::log 0 "$@" "stderr"
}

utils::info() {
	utils::log 1 "$@"
}

utils::debug() {
	utils::log 2 "$@"
}

utils::fail() {
  local exit_code=$1
  shift
  
	[ $# -gt 0 ] && utils::error "$@"
	exit $exit_code
}


#
# Dependency management
#
dependencies::getopt() {
  local exit_code
  
  set +e
  getopt --test > /dev/null
  exit_code=$?
  set -e
  
  [[ $exit_code -ne 4 ]] && return 1
  return 0
}


#
# Configuration
#


#
# Stack management
#
declare -a STACK
declare -i STACK_COUNTER=0

stack::add() {
	STACK+=($@)
}

stack::next() {
	local NEXT_COMMAND=${STACK[$STACK_COUNTER]}
	STACK_COUNTER+=1
	$NEXT_COMMAND
}

stack::run() {
	STACK_COUNTER=0
	stack::next
}


#
# Output
#
output::trace() {
	echo "Cronic detected failure or error output for the command:"
	echo "$@"
	echo
	echo "RESULT CODE: $RESULT"
	echo
	echo "ERROR OUTPUT:"
	cat "$ERR"
	echo
	echo "STANDARD OUTPUT:"
	cat "$OUT"
	if [ $TRACE != $ERR ]
	then
		echo
		echo "TRACE-ERROR OUTPUT:"
		cat "$TRACE"
	fi
}

#
# Chapecron own middlewares
#
chapecron::mktmp() {
	export TMP=$(mktemp -d 'chapecron.XXXXXXXXXX')
	export OUT=$TMP/cronic.out
	export ERR=$TMP/cronic.err
	export TRACE=$TMP/cronic.trace
	
	trap "{ rm -rf $TMP; }" EXIT
	
	stack::next
}

chapecron::run() {
	set +e
	stack::next >$OUT 2>$TRACE
	RESULT=$?
	set -e
	
	PATTERN="^${PS4:0:1}\\+${PS4:1}"
	if grep -aq "$PATTERN" $TRACE
	then
		! grep -av "$PATTERN" $TRACE > $ERR
	else
		ERR=$TRACE
	fi
	
	if [ $RESULT -ne 0 -o -s "$ERR" ]
	then
		echo -e $(output::trace $COMMAND)
	fi
}


#
# Here we go!
#
dependencies::getopt || utils::fail $ERROR_MISSING_DEPENDENCY "Missing dependency: enhanced getopt"

# Options
SHORT_OPTIONS=hvc:
LONG_OPTIONS=help,verbose,config:

self::usage() {
	cat <<-USAGE
		chapecron: look after your crons while you are away
		Usage: $0 [-v,--verbose] [-h,--help] [--] COMMAND
		Options:
		  -c,--config   Specify a configuration file (See below)
		  -h,--help     Print this help and exit
		  -v,--verbose  More verbose output
		
		By default, chapecron will look for configuration files at:
		
		- /etc/chapecron/chapecron.conf
		- XDG_CONFIG_HOME/chapecron/chapecron.conf
		  (usually ~/.config/chapecron/chapecron.conf)
		
		When specifying a configuration file as a command line option,
		only this file will be considered.
	USAGE
}

PARSED=$(getopt --options=$SHORT_OPTIONS --longoptions=$LONG_OPTIONS --name "$0" -- "$@")
eval set -- "$PARSED"
while :; do
	case "$1" in
		-c|--config)
			CONFIG_FILE=$2
			shift 2
			;;
		-v|--verbose)
			VERBOSE=1
			shift
			;;
		-h|--help)
			HELP=1
			shift
			;;
		--)
			shift
			break
			;;
		*)
		  utils::fail $ERROR_UNSUPPORTED_OPTION "Unsupported option $1. Use $0 -h to get help"
			;;
	esac
done

COMMAND="$@"


[[ $HELP = 1 ]] && self::usage && exit 0
[[ $VERBOSE = 1 ]] && echo "verbose: $VERBOSE, help: $HELP, command: $COMMAND"



eval_command() {
  eval $COMMAND
}


# Build the middleware stack and run it
stack::add chapecron::mktmp
stack::add chapecron::run
stack::add eval_command

stack::run
